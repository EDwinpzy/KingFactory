/*
 * @Author: EDwin
 * @Date: 2022-07-12 11:18:32
 * @LastEditors: EDwin
 * @LastEditTime: 2022-07-12 16:08:29
 */

//将当前数据记录的“启动标识”成员恢复为False

//订阅生产备库结果工序需求（对象的数据记录），获取生产备库方案ID

//查询生产备库结果工序需求、工艺路径、物料、生产备库规则配置。
//根据当前生产备库方案对象ID查询生产备库结果工序需求记录。
QueryPlanThingDataByTime(生产备库方案对象ID);

//查询所有工艺路径事对象的数据记录。（先不进行筛选）
QueryThingDefinitionAllMembers();

//查询物料记录。
QueryPlanThingDataByTime();

//查询生产备库规则配置记录
QueryPlanThingDataByTime();

//查询是否存在“生产备库结果排产数据”计划事对象，如果不存在则创建生产备库结果排产数据事对象,并设为生产备库结果工序需求事对象的子对象。
CreateChildPlanThingWithGivenID();

//拼接排产数据
let 排产数据 = [];
//获取输入数据，包括工序需求、在制品库存初始值、排产规则配置
let 工序需求集合 = 生产备库结果工序需求; //生产备库方案、全局工序顺序号、工序顺序号、工序、产品、半成品、总需求、开始时间、结束时间、启动标识
//在工序需求中增加工艺路径数据和生产备库规则配置数据
for (let i = 0; i < 工序需求集合.length; i++) {
    let 当前排产数据 = 工序需求集合[i];
    //根据工序需求的产品预定义筛选出工艺路径数据集合中该产品的工艺路径数据
    let 工艺路径数据 = 主计划_工艺路径的数据记录.filter((产品 = 当前排产数据.产品)); // 或者  let 工艺路径数据 = 主计划_工艺路径的数据记录.filter(半成品 = 当前排产数据.半成品);
    let 生产备库规则配置数据 = 生产备库规则配置所有数据.filter((生产备库方案 = 当前排产数据.生产备库方案));
    当前排产数据.资源选择规则名称 = 生产备库规则配置数据.资源选择规则名称;
    当前排产数据.日历 = 生产备库规则配置数据.日历;
    当前排产数据.启动标识 = false; //防止后APP提前启动
    for (let j = 0; j < 工艺路径数据.length; j++) {
        当前排产数据.流转方式 = 工艺路径数据[j].流转方式;
        当前排产数据.流转周期 = 工艺路径数据[j].流转周期;
        当前排产数据.良品率 = 工艺路径数据[j].良品率;
        当前排产数据.功能单元集合 = 工艺路径数据[j].功能单元集合; //[功能单元1,...]
        当前排产数据.产能 = 工艺路径数据[j].产能;
        当前排产数据.单位 = 工艺路径数据[j].单位;
        当前排产数据.输入输出类型 = 工艺路径数据[j].输入输出类型;
        当前排产数据.输入输出物料 = 工艺路径数据[j].输入输出物料;
        //....补全主计划_工艺路径下所有子的成员
        排产数据.push(当前排产数据);
    }
}
//在排产数据中添加全局排产数据顺序号
let 最大全局排产数据顺序号 = 0;
for (let i = 0; i < 排产数据.length; i++) {
    最大全局排产数据顺序号++;
    排产数据[i].全局排产数据顺序号 = 最大全局排产数据顺序号;
}
//更改启动标识
排产数据[排产数据.length - 1].启动标识 = true; //当前APP输出所有数据结果之后，后APP方可启动
//输出排产数据至生产备库结果排产数据事对象
AddPlanThingData();
