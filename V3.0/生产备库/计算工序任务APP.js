//订阅生产备库结果资源选择（计划事对象的数据记录）及生产备库结果生产计划（计划事对象的数据记录），当某个“启动标识”成员=True时，APP开始运行

//获取数据记录的“全局工序顺序号”成员值和"生产备库方案"成员值（中短期计划方案ID）
let inputParameter = {};
inputParameter.生产备库方案 = 获取的生产备库方案ID;
inputParameter.全局工序顺序号 = 获取的全局工序顺序号;

//2.查询是否存在“生产备库结果工序任务”计划事对象，若不存在则创建生产备库结果工序任务事对象,并设为生产备库结果资源选择事对象的子对象。
CreateChildPlanThingWithGivenID();

//若“启动标识”成员=True的数据记录属于生产备库结果资源选择（计划事对象）则运行function1(); 若“启动标识”成员=True的数据记录属于生产备库结果生产计划（计划事对象）则运行function2()
//若“启动标识”成员=True的数据记录属于生产备库结果资源选择（计划事对象）则运行function1()
if(("启动标识"成员=True的数据记录属于生产备库结果资源选择)and(生产备库结果资源选择数据记录的'是否首工序' = true)) {
    //3.1.1.依据当前生产备库方案ID查询生产备库结果资源选择记录。
    QueryPlanThingDataByTime();
    let 资源选择集合 = 依据生产备库方案ID查询获取的生产备库结果资源选择记录;
    //3.1.2.筛选出首工序资源选择集合
    首工序资源选择集合 = 资源选择集合.filter(ele => ele.是否首工序 = true);
    //按照全局资源选择顺序号、全局工序顺序号由小到大排序
    首工序资源选择集合 = 首工序资源选择集合.sort(全局资源选择顺序号, 全局工序顺序号);
    //3.1.3.获取首工序需求集合，并进行去重。筛选成员：生产备库方案、全局工序顺序号、工序顺序号、工序、产品、半成品、开始时间、结束时间、启动标识、功能单元、分配占比、产能、单位、是否首工序、日历、数量、流转方式、流转周期、良品率、是否首工序、是否末工序、前工序顺序号、后工序顺序号
    let 工序需求集合 = [];
    for(let i=0; i<首工序资源选择集合.length; i++) {
        let 当前工序资源选择 = 首工序资源选择集合[i];
        let 当前工序需求 = {};
        当前工序需求.生产备库方案   = 当前工序资源选择.生产备库方案;
        当前工序需求.全局工序顺序号  = 当前工序资源选择.全局工序顺序号;
        当前工序需求.工序顺序号    = 当前工序资源选择.工序顺序号;
        当前工序需求.工序   = 当前工序资源选择.工序;
        当前工序需求.产品   = 当前工序资源选择.产品;
        当前工序需求.半成品  = 当前工序资源选择.半成品;
        当前工序需求.开始时间 = 当前工序资源选择.开始时间;
        当前工序需求.结束时间 = 当前工序资源选择.结束时间;
        当前工序需求.启动标识 = false;//防止后APP提前启动
        当前工序需求.功能单元 = 当前工序资源选择.功能单元;
        当前工序需求.分配占比 = 当前工序资源选择.分配占比;
        当前工序需求.产能   = 当前工序资源选择.产能;
        当前工序需求.单位   = 当前工序资源选择.单位;
        当前工序需求.日历   = 当前工序资源选择.日历;
        当前工序需求.数量   = 当前工序资源选择.总需求;
        当前工序需求.流转方式 = 当前工序资源选择.流转方式;
        当前工序需求.流转周期 = 当前工序资源选择.流转周期;
        当前工序需求.良品率  = 当前工序资源选择.良品率;
        当前工序需求.是否首工序    = 当前工序资源选择.是否首工序;
        当前工序需求.是否末工序    = 当前工序资源选择.是否末工序;
        当前工序需求.前工序顺序号   = 当前工序资源选择.前工序顺序号;
        当前工序需求.后工序顺序号   = 当前工序资源选择.后工序顺序号;
        工序需求集合.push(当前工序需求);
    }
    //对工序需求集合进行去重。首工序资源选择集合中同一个生产备库方案、全局工序顺序号、功能单元，存在多个数据记录，包括输入、输出等，需要按照全局工序顺序号进行去重。
    工序需求集合 = 去重(工序需求集合);
    //3.1.4.运行函数1，每一个全局工序顺序号运行一次
    let 工序任务集合 = [];
    for(let i=0; i<工序需求集合.length; i++) {
        inputParameter.工序需求数据 = 工序需求集合[i];
        let 当前工序任务集合 = function1(inputParameter);
        工序任务集合.push(当前工序任务集合[0]);
    }
    //3.1.5.输出工序任务集合至生产备库结果工序任务记录
    AddPlanThingData();
}

//3.2.若“启动标识”成员=True的数据记录属于生产备库结果生产计划（计划事对象）则运行function2()
elseif("启动标识"成员=True的数据记录属于生产备库结果生产计划) {
    //3.2.1.依据获取的生产备库方案ID及全局工序顺序号查询生产备库结果生产计划数据记录。
    QueryThingDefinitionAllMembers();
    let 生产计划集合 = 依据生产备库方案ID及全局工序顺序号查询获取的生产备库结果生产计划数据记录;
    inputParameter.是否末工序 = 生产计划集合[0].是否末工序;
    inputParameter.生产计划集合 = 生产计划集合;
    if(inputParameter.是否末工序 = false) {
        //3.2.2.运行函数2，得出工序任务集合
        let 工序任务集合 = fuction2(inputParameter);
        //3.2.3.输出工序任务集合至生产备库结果工序任务记录
        AddPlanThingData(NameID thingID, String dataVersionName, String dataName, Int64 startTimeOffset, Int64 durationTime, Struct targetFieldValues);
    }
}