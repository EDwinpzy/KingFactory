function calculateProcessDemand(生产备库结果销售预测集合, 工艺路径集合) {
    // 1.按照全局订单顺序号升序、工序顺序号降序顺序计算工序需求
    let 工序需求集合 = [];
    for (let i = 0; i < 生产备库结果销售预测集合.length; i++) {
        // 1.1.依据当前销售预测产品查询工艺路径集合，获取当前销售预测对应的工艺路径
        let 当前工艺路径 = `产品 ==\"def_产品::${生产备库结果销售预测集合[i].产品}\"`; //[{产品: 生产备库结果销售预测集合[i].产品 ,半成品: ,流转方式: ,流转周期: ,良品率: ,工序: ,工序顺序号: ,前工序顺序号: ,后工序顺序号: ,功能单元集合: ,产能: ,单位: ,是否首工序: ,是否末工序: ,输入输出类型: ,输入输出物料: ,配比: },...]
        //对当前工艺路径按照加工顺序升序排序
        当前工艺路径 = 当前工艺路径.sort(加工顺序);
        // 1.2.计算当前销售预测的工序需求
        for (let j = 当前工艺路径.length; j > 0; j--) {
            let 当前工序需求 = {};
            当前工序需求.生产备库方案 = 生产备库结果销售预测集合[i].生产备库方案;
            当前工序需求.全局订单顺序号 = 生产备库结果销售预测集合[i].全局订单顺序号;
            当前工序需求.工序顺序号 = j;
            当前工序需求.工序 = 当前工艺路径[j].工序;
            当前工序需求.产品 = 生产备库结果销售预测集合[i].产品;
            当前工序需求.半成品 = 当前工艺路径[j].半成品;
            当前工序需求.启动标识 = false; //防止后APP提前启动
            //按照是否为最后工序计算工序总需求
            if ((当前工艺路径[j].是否末工序 = true)) {
                let 主计划_输出物料 = QuerySpecificChildPlanThing(); //根据主计划_工艺路径预定义ID查询主计划_输出物料的数据
                当前工序需求.总需求 = 生产备库结果销售预测集合[i].数量 / 主计划_物料输出.良品率;
            } else {
                let 主计划_输入物料 = QuerySpecificChildPlanThing(); //根据主计划_工艺路径预定义ID查询主计划_输入物料的数据
                let 主计划_输出物料 = QuerySpecificChildPlanThing(); //根据主计划_工艺路径预定义ID查询主计划_输出物料的数据
                当前工序需求.总需求 = 当前工序需求[j + 1].总需求 / 主计划_物料输出.良品率 / 主计划_物料输入.损耗率;
            }
            工序需求集合.push(当前工序需求); //生产备库方案、全局工序顺序号、工序顺序号、工序、产品、半成品、总需求、开始时间、结束时间、启动标识
        }
    }
    // 3.对工序需求集合进行排序，按照全局订单顺序号升序、工序顺序号升序
    工序需求集合 = 工序需求集合.sort(全局订单顺序号, 工序顺序号);
    // 4.在工序需求集合中添加全局工序顺序号
    let 最大全局工序顺序号 = 0;
    for (let i = 0; i < 工序需求集合.length; i++) {
        最大全局工序顺序号++;
        工序需求集合[i].全局工序顺序号 = 最大全局工序顺序号;
    }
    // 5.更改启动标识
    工序需求集合[工序需求集合.length - 1].启动标识 = true; //当前APP输出所有数据结果之后，后APP方可启动
    // 6.返回工序需求集合
    return 工序需求集合;
}
