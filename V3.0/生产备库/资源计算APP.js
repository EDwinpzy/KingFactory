/*
 * @Author: EDwin
 * @Date: 2022-07-13 09:18:29
 * @LastEditors: EDwin
 * @LastEditTime: 2022-07-13 13:33:16
 */
//1.APP开始运行。KingFactory3.8启动时，APP自动启动。订阅生产备库结果排产数据（对象的数据记录），当某个“启动标识”成员=True时，APP开始运行
//1.1.订阅生产备库结果排产数据（对象的数据记录）
订阅生产备库结果排产数据数据记录;
let thisUser = '系统管理员';
let thisAPPName = '生产备库_资源选择APP';

//1.2.运行资源选择APP
运行资源选择APP;
//1.3.将当前数据记录的“启动标识”成员恢复为False

//1.4.获取生产备库方案ID

//2.查询生产备库结果排产数据。
//2.1.依据当前生产备库方案ID查询生产备库结果排产数据记录。
QueryPlanThingDataByTime();

//3.查询是否存在“生产备库结果资源选择”计划事对象，若不存在则创建生产备库结果资源选择事对象,并设为生产备库结果排产数据事对象的子对象。
CreateChildPlanThingWithGivenID();

//4.进行资源选择
let 资源选择 = [];
//4.1.获取排产数据
let 排产数据集合 = 生产备库结果排产数据; //[{生产备库方案:, 全局排产数据顺序号:, 全局工序顺序号:, 工序顺序号:, 工序:, 产品:, 半成品:, 总需求:, 开始时间:, 结束时间:, 启动标识:, 流转方式:, 流转周期:, 良品率:, 功能单元集合:, 是否首工序:, 前工序顺序号:, 输入输出类型:, 输入输出物料:, 配比:, 排产方向:, 资源选择规则名称: , 日历：},...]
let 当前方案资源选择规则 = 排产数据集合[0].资源选择规则名称;
let 资源日历配置 = 排产数据集合[0].日历; //[{生产备库方案:, 功能单元：，日历：},...]
//4.2.获取工序资源集合，去掉重复数据，全局工序顺序号为唯一标识符
let 工序需求集合 = 排产数据集合的部分成员数组; //成员包括：生产备库方案、全局工序顺序号、工序顺序号、工序、产品、半成品、总需求、开始时间、结束时间、功能单元集合、产能
let 工序资源集合 = 排产数据集合中去掉重复元素;
//4.3.进行工序资源选择
for (let i = 0; i < 工序资源集合.length; i++) {
    //获取当前工序资源的功能单元集合
    let 当前功能单元集合 = 工序资源集合[i].功能单元集合; //[功能单元1, ...]
    //若功能单元集合中规定了有且仅有一个功能单元，则使用该功能单元
    if (当前功能单元集合中有且仅有一个功能单元) {
        工序资源集合[i].功能单元 = 当前功能单元集合[0].名称;
    } else {
        //按照资源选择规则，从功能单元集合中选择一个最优功能单元
        switch (当前方案资源选择规则) {
            case 剩余产能最大:
                //查询生产备库结果生产计划，从当前功能单元集合中选择未来365天的总产能剩余最大的功能单元
                for (let j = 0; j < 当前功能单元集合.length; j++) {
                    let 资源日历配置中功能单元未来365天的出勤天数 = 查询资源日历配置得出当前功能单元集合[j].未来365天的出勤天数; //简化计算时，可以默认365天
                    let 未来365天的产能占用天数 = 查询生产备库结果生产计划得出当前功能单元集合[j].未来365天计划占用天数;
                    当前功能单元集合[j].剩余产能 = 工序资源集合[i].产能 * (资源日历配置中功能单元未来365天的出勤天数 - 未来365天的产能占用天数);
                }
                工序资源集合[i].功能单元 = 当前功能单元集合中剩余产能最大的功能单元;
                break;
            case 剩余产能最小:
                //查询生产备库结果生产计划，从当前功能单元集合中选择未来365天的总产能剩余最小的功能单元
                for (let j = 0; j < 当前功能单元集合.length; j++) {
                    let 资源日历配置中功能单元未来365天的出勤天数 = 查询资源日历配置得出当前功能单元集合[j].未来365天的出勤天数; //简化计算时，可以默认365天
                    let 未来365天的产能占用天数 = 查询生产备库结果生产计划得出当前功能单元集合[j].未来365天计划占用天数;
                    当前功能单元集合[j].剩余产能 = 工序资源集合[i].产能 * (资源日历配置中功能单元未来365天的出勤天数 - 未来365天的产能占用天数);
                }
                工序资源集合[i].功能单元 = 当前功能单元集合中剩余产能最小的功能单元;
                break;
            case 产能最大:
                //从当前功能单元集合中选择产能最大的功能单元
                工序资源集合[i].功能单元 = 当前功能单元集合中产能最大的功能单元;
                break;
            case 产能最小:
                //从当前功能单元集合中选择产能最小的功能单元
                工序资源集合[i].功能单元 = 当前功能单元集合中产能最小的功能单元;
                break;
            default:
                //从当前功能单元集合中选择第一个功能单元
                工序资源集合[i].功能单元 = 当前功能单元集合[0].名称;
                break;
        }
    }
}
//4.4.获取资源选择集合，将工序资源集合中的功能单元写入相同全局工序顺序号的排产数据集合
let 资源选择集合 = 排产数据集合;
for (let i = 0; i < 排产数据集合.length; i++) {
    资源选择集合[i].全局资源选择顺序号 = 排产数据集合[i].全局排产数据顺序号;
    资源选择集合[i].启动标识 = false; //防止后APP提前启动
    for (let j = 0; j < 工序资源集合.length; j++) {
        if ((资源选择集合[i].全局工序顺序号 = 工序资源集合[j].全局工序顺序号)) {
            资源选择集合[i].功能单元 = 工序资源集合[j].功能单元;
        }
    }
}
//4.5.对资源选择集合进行排序，按照全局资源选择顺序号升序
资源选择集合.sort(全局资源选择顺序号);
//4.6.更改最后一个资源选择的启动标识为true
资源选择集合[资源选择集合.length - 1].启动标识 = true; //当前APP输出所有数据结果之后，后APP方可启动
//5.输出资源选择集合至生产备库结果资源选择记录
AddPlanThingData();
